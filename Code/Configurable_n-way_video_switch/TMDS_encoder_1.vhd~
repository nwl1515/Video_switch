----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date:    15:43:05 02/27/2016 
-- Design Name: 
-- Module Name:    TMDS_encoder - Structural 
-- Project Name: 
-- Target Devices: 
-- Tool versions: 
-- Description: 
--
-- Dependencies: 
--
-- Revision: 
-- Revision 0.01 - File Created
-- Additional Comments: 
--
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_SIGNED.ALL;


entity TMDS_encoder is
    Port ( Pixel_clock : in  STD_LOGIC;
           Data_n8 : in  STD_LOGIC_VECTOR (7 downto 0);
           Control : in  STD_LOGIC_VECTOR (1 downto 0);
           Video_active : in  STD_LOGIC;
           Data_n10 : out  STD_LOGIC_VECTOR (9 downto 0));
end TMDS_encoder;

architecture Structural of TMDS_encoder is

signal data_pipeline										: std_logic_vector(7 downto 0);		-- Original 8 bit
signal q_m, q_m_xor, q_m_xnor, q_m_pipeline		: std_logic_vector(8 downto 0);		-- 9 bit
signal control_token, q_out, q_out_pipeline		: std_logic_vector(9 downto 0);		-- 10 bit
signal n1_pipeline, n1_q_m, int_n1_q_m				: std_logic_vector(4 downto 0);		-- num of ones   signed
signal n0_q_m												: std_logic_vector(4 downto 0);		-- num of zeroes  signed
signal dc_bias												: std_logic_vector(4 downto 0) := "00000";	-- dc_bias signed
signal cnt_t_1, cnt_t									: std_logic_vector(4 downto 0) := "00000"; -- disparity signed
signal control_pipeline, control_pipeline_2		: std_logic_vector(1 downto 0);	-- control signals
signal a_video_pipeline, a_video_pipeline_2		: std_logic;							-- active video
signal balanced, not_balanced							: std_logic;							-- balanced signals?
signal q_m_double, not_q_m_double					: std_logic_vector(4 downto 0);

begin




-----------------------------------
-- Stage 1
-- Pipeline inputs, and count ones in data
-----------------------------------
	pipeline_stage_1 : process(Pixel_clock)
	begin
		if rising_edge(Pixel_clock) then
			a_video_pipeline <= Video_active;
			data_pipeline <= Data_n8;
			control_pipeline <= Control;
			-- Count number of ones
			n1_pipeline <= CONV_STD_LOGIC_VECTOR(0,n1_pipeline'Length) + Data_n8(0) + Data_n8(1) + Data_n8(2) + Data_n8(3) + Data_n8(4) + Data_n8(5) + Data_n8(6) + Data_n8(7);
		end if;
	end process pipeline_stage_1;
	
-----------------------------------
-- Encodings - based on pipelined data
-----------------------------------

	q_m_xor(0) <= data_pipeline(0);
	q_m_xor(1) <= data_pipeline(1) xor data_pipeline(0);
	q_m_xor(2) <= data_pipeline(2) xor data_pipeline(1);
	q_m_xor(3) <= data_pipeline(3) xor data_pipeline(2);
	q_m_xor(4) <= data_pipeline(4) xor data_pipeline(3);
	q_m_xor(5) <= data_pipeline(5) xor data_pipeline(4);
	q_m_xor(6) <= data_pipeline(6) xor data_pipeline(5);
	q_m_xor(7) <= data_pipeline(7) xor data_pipeline(6);
	q_m_xor(8) <= '1';
	
	q_m_xnor(0) <= data_pipeline(0);
	q_m_xnor(1) <= data_pipeline(1) xnor data_pipeline(0);
	q_m_xnor(2) <= data_pipeline(2) xnor data_pipeline(1);
	q_m_xnor(3) <= data_pipeline(3) xnor data_pipeline(2);
	q_m_xnor(4) <= data_pipeline(4) xnor data_pipeline(3);
	q_m_xnor(5) <= data_pipeline(5) xnor data_pipeline(4);
	q_m_xnor(6) <= data_pipeline(6) xnor data_pipeline(5);
	q_m_xnor(7) <= data_pipeline(7) xnor data_pipeline(6);
	q_m_xnor(8) <= '0';
	
-------------------------------------
-- Choose encoding
-------------------------------------

	q_m <= q_m_xnor when n1_pipeline > 4 or (n1_pipeline = 4 and data_pipeline(0) = '0') else q_m_xor;
	
-------------------------------------
-- Pipeline stage 2
-- Balance DC
-------------------------------------
	-- count ones
	int_n1_q_m <= CONV_STD_LOGIC_VECTOR(0, int_n1_q_m'Length) + q_m(0) + q_m(1) + q_m(2) + q_m(3) + q_m(4) + q_m(5) + q_m(6) + q_m(7);
	
	balance : process(Pixel_clock)
	begin
		if rising_edge(Pixel_clock) then
			n1_q_m <= int_n1_q_m;
			n0_q_m <= "01000" - int_n1_q_m;
			q_m_pipeline <= q_m;
			control_pipeline_2 <= control_pipeline;
			a_video_pipeline_2 <= a_video_pipeline;
		end if;
	end process balance;
	
	balanced <= '1' when cnt_t_1 = 0 or n1_q_m = n0_q_m else '0';
	
	not_balanced <= '1' when (cnt_t_1 > 0 and n1_q_m > n0_q_m) or (cnt_t_1 < 0 and n0_q_m > n1_q_m) else '0';
	
	control_token <= "1101010100" when control_pipeline_2 = "00" else 
							"0010101011" when control_pipeline_2 = "01" else
							"0101010100" when control_pipeline_2 = "10" else
							"1010101011";
							
	q_out <= control_token when a_video_pipeline_2 = '0' else
				not q_m_pipeline(8) & q_m_pipeline(8) & not q_m_pipeline(7 downto 0) when balanced = '1' and q_m_pipeline(8) = '0' else
				not q_m_pipeline(8) & q_m_pipeline(8) & q_m_pipeline(7 downto 0)	when balanced = '1' and q_m_pipeline(8) = '1' else
				'1' & q_m_pipeline(8) & not q_m_pipeline(7 downto 0)	when not_balanced = '1' else
				'0' & q_m_pipeline(8) & q_m_pipeline(7 downto 0);
				
	dc_bias <= n0_q_m - n1_q_m;
	
	q_m_double <= EXT(q_m(8) & '0', cnt_t'Length);
	not_q_m_double <= EXT(not q_m(8) & '0', cnt_t'Length);
	
	cnt_t <= "00000" when a_video_pipeline_2 = '0' else
				cnt_t_1 + dc_bias when balanced = '1' and q_m_pipeline(8) = '0' else
				cnt_t_1 - dc_bias when balanced = '1' and q_m_pipeline(8) = '1' else
				cnt_t_1 + q_m_double + dc_bias when not_balanced = '1' else
				cnt_t_1 - not_q_m_double - dc_bias;
				
----------------------------------
-- Pipeline stage 3
-- Output
----------------------------------
		output : process(Pixel_clock)
		begin
			if rising_edge(Pixel_clock) then
				cnt_t_1 <= cnt_t;
				q_out_pipeline <= q_out;
			end if;
		end process output;
		
	Data_n10 <= q_out_pipeline;
	
end Structural;

